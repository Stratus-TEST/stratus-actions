name: Sync from Upstream

# This workflow strictly synchronizes a fork with its upstream repository:
# 1. Syncs branches (currently main) to match upstream using GitHub API:
#    - Force updates existing branches to match upstream
#    - Creates branches that don't exist in the fork
#    - FAILS the workflow if any branch can't be created or updated to match upstream
# 2. Syncs all tags to match upstream using GitHub API with force updates:
#    - Creates new tags that don't exist in the fork
#    - For existing tags pointing to different commits:
#      - First checks if tag exists via API
#      - Deletes existing tag
#      - Creates new tag with the correct commit SHA
#    - FAILS the workflow if any tag can't be created or updated to match upstream
#    - Note: The workflow will explicitly try to sync ALL tags, including 'v1' and 'latest'
# 3. Mirrors all releases from upstream to the fork:
#    - Creates new releases in the fork that exist in upstream
#    - FAILS the workflow if any release can't be mirrored
#
# Note: The workflow will FAIL if it can't synchronize ALL branches, tags, and releases with upstream
#
# IMPORTANT: For the "Resource not accessible by integration" errors with tags:
# 1. First try: Disable tag protection rules in GitHub repository settings (Settings â†’ Branches â†’ Tag protection rules)
# 2. If that doesn't work: Create a Personal Access Token (PAT) with the 'repo' scope and add it to repository
#    secrets as SYNC_PAT, then change 'github-token: ${{ secrets.GITHUB_TOKEN }}' to 'github-token: ${{ secrets.SYNC_PAT }}'
#    in the tag sync step below
#
# The workflow runs hourly by default and can also be triggered manually.

on:
  schedule:
    - cron: "0 * * * *" # every hour
  workflow_dispatch:

permissions:
  contents: write # Needed for branch/tag updates and releases

jobs:
  sync-upstream:
    name: Synchronize with Upstream Repository
    runs-on: ubuntu-latest
    if: github.repository == 'hafslundecovannkraft/stratus-actions' # Only run on the forked repository
    env:
      FORK_REPO: hafslundecovannkraft/stratus-actions # This repository
      UPSTREAM_REPO: stratusdata/stratus-actions # The upstream repository to sync from
    steps:
      - name: Checkout fork
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Set up Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Sync branches from upstream using GitHub API
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const upstream = process.env.UPSTREAM_REPO;
            const [upstreamOwner, upstreamRepo] = upstream.split('/');
            const branchesToSync = ['main']; // List of branches to sync with upstream
            const failedBranches = [];

            console.log(`Syncing branches from upstream: ${upstream} to ${context.repo.owner}/${context.repo.repo}`);

            for (const branchName of branchesToSync) {
              console.log(`Syncing branch: ${branchName}`);

              try {
                // Get the latest commit SHA from upstream branch
                const { data: upstreamBranch } = await github.rest.repos.getBranch({
                  owner: upstreamOwner,
                  repo: upstreamRepo,
                  branch: branchName
                });

                const upstreamSha = upstreamBranch.commit.sha;
                console.log(`Latest upstream commit SHA for ${branchName}: ${upstreamSha}`);

                // Get current reference to update
                try {
                  const { data: reference } = await github.rest.git.getRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `heads/${branchName}`
                  });

                  if (reference.object.sha === upstreamSha) {
                    console.log(`Branch ${branchName} already up to date with upstream.`);
                    continue; // Skip to next branch
                  }

                  // Update reference to match upstream
                  try {
                    await github.rest.git.updateRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: `heads/${branchName}`,
                      sha: upstreamSha,
                      force: true
                    });
                    console.log(`Successfully updated ${branchName} branch to match upstream commit ${upstreamSha}`);
                  } catch (updateError) {
                    console.error(`Error updating branch ${branchName}:`, updateError.message);
                    failedBranches.push(`${branchName} (update failed)`);
                  }
                } catch (refError) {
                  console.error(`Error getting reference for branch ${branchName}:`, refError.message);

                  // If the branch doesn't exist, try to create it
                  console.log(`Attempting to create branch ${branchName}...`);
                  try {
                    await github.rest.git.createRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: `refs/heads/${branchName}`,
                      sha: upstreamSha
                    });
                    console.log(`Successfully created branch ${branchName} at commit ${upstreamSha}`);
                  } catch (createError) {
                    console.error(`Error creating branch ${branchName}:`, createError.message);
                    failedBranches.push(`${branchName} (create failed)`);
                  }
                }
              } catch (branchError) {
                console.error(`Error getting upstream branch ${branchName}:`, branchError.message);
                failedBranches.push(`${branchName} (upstream access failed)`);
              }
            }

            // Fail the workflow if any branches couldn't be synced
            if (failedBranches.length > 0) {
              const errorMessage = `Failed to sync the following branches with upstream: ${failedBranches.join(", ")}`;
              console.error(errorMessage);
              throw new Error(errorMessage);
            }

      - name: Sync tags from upstream with force update when needed
        uses: actions/github-script@v7
        with:
          # If you encounter issues with protected tags, replace GITHUB_TOKEN with SYNC_PAT
          # where SYNC_PAT is a secret containing a Personal Access Token with repo scope
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const upstream = process.env.UPSTREAM_REPO;
            const [upstreamOwner, upstreamRepo] = upstream.split('/');

            console.log(`Syncing tags from upstream: ${upstream}`);

            // Get all tags from upstream
            const { data: upstreamTags } = await github.rest.repos.listTags({
              owner: upstreamOwner,
              repo: upstreamRepo,
              per_page: 100
            });

            // Get all tags in the current repo
            const { data: forkTags } = await github.rest.repos.listTags({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });

            // Convert fork tags to a map of name -> commit SHA for easy lookup
            const existingTagMap = new Map();
            forkTags.forEach(tag => {
              existingTagMap.set(tag.name, tag.commit.sha);
            });

            // All tags are now considered critical - we'll fail the workflow if any tag can't be synced
            // This list just helps identify common tags that might be protected
            const commonProtectedTags = ['v1', 'latest'];

            // Create or update tags in the fork
            const failedTags = [];

            for (const tag of upstreamTags) {
              // First check if tag exists in the repository via API
              // This ensures we have accurate information about tag existence
              let tagExists = false;
              try {
                // Try to get the tag reference from GitHub
                try {
                  const { data: tagRef } = await github.rest.git.getRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `tags/${tag.name}`
                  });
                  tagExists = true;

                  // Update our map with accurate information
                  existingTagMap.set(tag.name, tagRef.object.sha);
                } catch (refError) {
                  // If we get a 404, the tag doesn't exist
                  if (refError.status === 404) {
                    tagExists = false;
                  } else {
                    throw refError; // Re-throw other errors
                  }
                }

                if (!tagExists) {
                  // Case 1: Tag doesn't exist in fork, create it
                  console.log(`Creating new tag ${tag.name} with commit ${tag.commit.sha}`);
                  try {
                    await github.rest.git.createRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: `refs/tags/${tag.name}`,
                      sha: tag.commit.sha
                    });
                    console.log(`Successfully created tag: ${tag.name}`);
                  } catch (error) {
                    console.error(`Error creating tag ${tag.name}:`, error);
                    failedTags.push(`${tag.name} (create failed)`);
                  }
                } else if (existingTagMap.get(tag.name) !== tag.commit.sha) {
                  // Case 2: Tag exists but points to different commit SHA, update it
                  console.log(`Tag ${tag.name} exists but points to different commit - attempting force update`);
                  console.log(`  Current: ${existingTagMap.get(tag.name)}`);
                  console.log(`  Upstream: ${tag.commit.sha}`);

                  let updateSucceeded = false;

                  // Step 1: Try to delete the existing tag
                  try {
                    await github.rest.git.deleteRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: `tags/${tag.name}`
                    });

                    // Step 2: Create new tag at the correct commit
                    try {
                      await github.rest.git.createRef({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        ref: `refs/tags/${tag.name}`,
                        sha: tag.commit.sha
                      });
                      console.log(`Successfully force updated tag: ${tag.name} to commit ${tag.commit.sha}`);
                      updateSucceeded = true;
                    } catch (createError) {
                      console.error(`Error creating tag ${tag.name} after deletion:`, createError.message);
                    }
                  } catch (deleteError) {
                    console.log(`Could not delete tag ${tag.name}: ${deleteError.message}`);

                    // If deletion fails, it could be due to branch protection rules
                    // In some repositories, we might still want to try updating the reference directly
                    console.log(`Attempting to update tag ${tag.name} directly without deletion...`);

                    try {
                      // Try to update the reference directly (may fail on protected tags)
                      await github.rest.git.updateRef({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        ref: `tags/${tag.name}`,
                        sha: tag.commit.sha,
                        force: true
                      });
                      console.log(`Successfully updated tag ${tag.name} directly to ${tag.commit.sha}`);
                      updateSucceeded = true;
                    } catch (updateError) {
                      console.error(`Error updating tag ${tag.name} directly:`, updateError.message);
                      console.log(`Failed to update tag ${tag.name} - may require admin access or be protected`);
                    }
                  }

                  if (!updateSucceeded) {
                    console.log(`âŒ Failed to update tag ${tag.name} to match upstream`);
                    failedTags.push(`${tag.name} (update failed)`);
                  }
                } else {
                  // Case 3: Tag exists and already matches upstream
                  console.log(`Tag ${tag.name} already matches upstream commit ${tag.commit.sha}`);
                }
              } catch (error) {
                console.error(`Error processing tag ${tag.name}:`, error.message);
                failedTags.push(`${tag.name} (processing error: ${error.message})`);
              }
            }

            // Fail the workflow for ALL tags including protected tags
            if (failedTags.length > 0) {
              const errorMessage = `Failed to sync the following tags with upstream: ${failedTags.join(", ")}`;
              console.error(errorMessage);
              console.log(`
              âš ï¸ TAG SYNC FAILURE âš ï¸
              Some tags could not be synced due to permission issues or tag protection.

              To resolve this:
              1. Disable tag protection rules in GitHub repository settings
                 (Settings â†’ Branches â†’ Tag protection rules)
              2. OR: Use a Personal Access Token (PAT) with 'repo' scope by:
                 - Generate a PAT at https://github.com/settings/tokens with 'repo' scope
                 - Add it to repository secrets as SYNC_PAT
                 - Update this workflow to use SYNC_PAT instead of GITHUB_TOKEN
                 - Change github-token parameter in this workflow file to use the SYNC_PAT secret
              `);
              throw new Error(errorMessage);
            }

      - name: Mirror releases from upstream
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const upstream = process.env.UPSTREAM_REPO;
            const [upstreamOwner, upstreamRepo] = upstream.split('/');

            console.log(`Mirroring releases from upstream: ${upstream}`);

            try {
              // Get all releases from upstream
              const { data: upstreamReleases } = await github.rest.repos.listReleases({
                owner: upstreamOwner,
                repo: upstreamRepo,
                per_page: 100
              });

              console.log(`Found ${upstreamReleases.length} releases in upstream repository`);

              // Get all releases in the current repo
              const { data: forkReleases } = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });

              console.log(`Found ${forkReleases.length} releases in fork repository`);
              const forkReleases_map = new Map();
              forkReleases.forEach(release => {
                forkReleases_map.set(release.tag_name, release);
              });

              // Mirror releases that don't exist in the fork
              let mirrored = 0;
              const failedReleases = [];

              for (const release of upstreamReleases) {
                if (!forkReleases_map.has(release.tag_name)) {
                  console.log(`Mirroring release: ${release.tag_name} - ${release.name}`);
                  try {
                    await github.rest.repos.createRelease({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      tag_name: release.tag_name,
                      name: release.name,
                      body: `${release.body || ''}\n\n---\n*This release was automatically mirrored from the upstream repository.*`,
                      draft: release.draft,
                      prerelease: release.prerelease,
                      target_commitish: release.target_commitish || 'main'
                    });
                    mirrored++;
                    console.log(`Successfully mirrored release: ${release.tag_name}`);
                  } catch (error) {
                    console.error(`Error mirroring release ${release.tag_name}:`, error.message);
                    failedReleases.push(`${release.tag_name} (${error.message})`);
                  }
                }
              }

              // Fail the workflow if any releases couldn't be mirrored
              if (failedReleases.length > 0) {
                const errorMessage = `Failed to mirror the following releases: ${failedReleases.join(", ")}`;
                console.error(errorMessage);
                throw new Error(errorMessage);
              }

              console.log(`Sync complete. Successfully mirrored ${mirrored} new releases.`);
            } catch (error) {
              console.error('Error in release mirroring process:', error);
              throw error;
            }

      - name: Sync Summary
        run: |
          echo "## Repository Sync Summary" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Branch Sync**: All branches synchronized with upstream" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Tags Sync**: All tags synchronized with upstream (workflow fails if any tag sync fails)" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Release Sync**: All releases mirrored from upstream" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ”„ Synchronized with upstream: $UPSTREAM_REPO" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Last sync time: $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "â„¹ï¸ **Note**: This workflow strictly enforces complete synchronization with upstream. If any branch, tag, or release fails to sync, the entire workflow will fail." >> $GITHUB_STEP_SUMMARY
