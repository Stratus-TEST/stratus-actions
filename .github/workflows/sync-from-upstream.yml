name: Sync from Upstream

# This workflow synchronizes a fork with its upstream repository:
# 1. Syncs branches (currently main) to match upstream using GitHub API:
#    - Force updates existing branches to match upstream
#    - Creates branches that don't exist in the fork
#    - FAILS the workflow if any branch can't be created or updated to match upstream
# 2. Syncs all tags to match upstream using GitHub API with force updates:
#    - Creates new tags that don't exist in the fork
#    - Force updates existing tags that point to different commits (using multiple methods)
#    - FAILS the workflow if any tag can't be created or updated to match upstream
# 3. Mirrors all releases from upstream to the fork:
#    - Creates new releases in the fork that exist in upstream
#    - FAILS the workflow if any release can't be mirrored
#
# Note: The workflow will fail if it can't synchronize ALL branches, tags, and releases with upstream
# The workflow runs hourly by default and can also be triggered manually.

on:
  schedule:
    - cron: "0 * * * *" # every hour
  workflow_dispatch:

permissions:
  contents: write # Needed for branch/tag updates and releases

jobs:
  sync-upstream:
    name: Synchronize with Upstream Repository
    runs-on: ubuntu-latest
    if: github.repository == 'hafslundecovannkraft/stratus-actions' # Only run on the forked repository
    env:
      FORK_REPO: hafslundecovannkraft/stratus-actions # This repository
      UPSTREAM_REPO: stratus-test/stratus-actions # The upstream repository to sync from
    steps:
      - name: Checkout fork
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Set up Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Sync branches from upstream using GitHub API
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const upstream = process.env.UPSTREAM_REPO;
            const [upstreamOwner, upstreamRepo] = upstream.split('/');
            const branchesToSync = ['main']; // List of branches to sync with upstream
            const failedBranches = [];

            console.log(`Syncing branches from upstream: ${upstream} to ${context.repo.owner}/${context.repo.repo}`);

            for (const branchName of branchesToSync) {
              console.log(`Syncing branch: ${branchName}`);

              try {
                // Get the latest commit SHA from upstream branch
                const { data: upstreamBranch } = await github.rest.repos.getBranch({
                  owner: upstreamOwner,
                  repo: upstreamRepo,
                  branch: branchName
                });

                const upstreamSha = upstreamBranch.commit.sha;
                console.log(`Latest upstream commit SHA for ${branchName}: ${upstreamSha}`);

                // Get current reference to update
                try {
                  const { data: reference } = await github.rest.git.getRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `heads/${branchName}`
                  });

                  if (reference.object.sha === upstreamSha) {
                    console.log(`Branch ${branchName} already up to date with upstream.`);
                    continue; // Skip to next branch
                  }

                  // Update reference to match upstream
                  try {
                    await github.rest.git.updateRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: `heads/${branchName}`,
                      sha: upstreamSha,
                      force: true
                    });
                    console.log(`Successfully updated ${branchName} branch to match upstream commit ${upstreamSha}`);
                  } catch (updateError) {
                    console.error(`Error updating branch ${branchName}:`, updateError.message);
                    failedBranches.push(`${branchName} (update failed)`);
                  }
                } catch (refError) {
                  console.error(`Error getting reference for branch ${branchName}:`, refError.message);

                  // If the branch doesn't exist, try to create it
                  console.log(`Attempting to create branch ${branchName}...`);
                  try {
                    await github.rest.git.createRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: `refs/heads/${branchName}`,
                      sha: upstreamSha
                    });
                    console.log(`Successfully created branch ${branchName} at commit ${upstreamSha}`);
                  } catch (createError) {
                    console.error(`Error creating branch ${branchName}:`, createError.message);
                    failedBranches.push(`${branchName} (create failed)`);
                  }
                }
              } catch (branchError) {
                console.error(`Error getting upstream branch ${branchName}:`, branchError.message);
                failedBranches.push(`${branchName} (upstream access failed)`);
              }
            }

            // Fail the workflow if any branches couldn't be synced
            if (failedBranches.length > 0) {
              const errorMessage = `Failed to sync the following branches with upstream: ${failedBranches.join(", ")}`;
              console.error(errorMessage);
              throw new Error(errorMessage);
            }

      - name: Sync tags from upstream with force update when needed
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const upstream = process.env.UPSTREAM_REPO;
            const [upstreamOwner, upstreamRepo] = upstream.split('/');

            console.log(`Syncing tags from upstream: ${upstream}`);

            // Get all tags from upstream
            const { data: upstreamTags } = await github.rest.repos.listTags({
              owner: upstreamOwner,
              repo: upstreamRepo,
              per_page: 100
            });

            // Get all tags in the current repo
            const { data: forkTags } = await github.rest.repos.listTags({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });

            // Convert fork tags to a map of name -> commit SHA for easy lookup
            const existingTagMap = new Map();
            forkTags.forEach(tag => {
              existingTagMap.set(tag.name, tag.commit.sha);
            });

            // Create or update tags in the fork
            const failedTags = [];

            for (const tag of upstreamTags) {
              if (!existingTagMap.has(tag.name)) {
                // Case 1: Tag doesn't exist in fork, create it
                console.log(`Creating new tag ${tag.name} with commit ${tag.commit.sha}`);
                try {
                  await github.rest.git.createRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `refs/tags/${tag.name}`,
                    sha: tag.commit.sha
                  });
                  console.log(`Successfully created tag: ${tag.name}`);
                } catch (error) {
                  console.error(`Error creating tag ${tag.name}:`, error);
                  failedTags.push(`${tag.name} (create failed)`);
                }
              } else if (existingTagMap.get(tag.name) !== tag.commit.sha) {
                // Case 2: Tag exists but points to different commit SHA, update it
                console.log(`Tag ${tag.name} exists but points to different commit - attempting force update`);
                console.log(`  Current: ${existingTagMap.get(tag.name)}`);
                console.log(`  Upstream: ${tag.commit.sha}`);

                let updateSucceeded = false;

                // Step 1: Try to delete the existing tag
                try {
                  await github.rest.git.deleteRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `tags/${tag.name}`
                  });

                  // Step 2: Create new tag at the correct commit
                  try {
                    await github.rest.git.createRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: `refs/tags/${tag.name}`,
                      sha: tag.commit.sha
                    });
                    console.log(`Successfully force updated tag: ${tag.name} to commit ${tag.commit.sha}`);
                    updateSucceeded = true;
                  } catch (createError) {
                    console.error(`Error creating tag ${tag.name} after deletion:`, createError.message);
                  }
                } catch (deleteError) {
                  console.log(`Could not delete tag ${tag.name}: ${deleteError.message}`);

                  // If deletion fails, it could be due to branch protection rules
                  // In some repositories, we might still want to try updating the reference directly
                  console.log(`Attempting to update tag ${tag.name} directly without deletion...`);

                  try {
                    // Try to update the reference directly (may fail on protected tags)
                    await github.rest.git.updateRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: `tags/${tag.name}`,
                      sha: tag.commit.sha,
                      force: true
                    });
                    console.log(`Successfully updated tag ${tag.name} directly to ${tag.commit.sha}`);
                    updateSucceeded = true;
                  } catch (updateError) {
                    console.error(`Error updating tag ${tag.name} directly:`, updateError.message);
                    console.log(`Failed to update tag ${tag.name} - may require admin access or be protected`);
                  }
                }

                if (!updateSucceeded) {
                  console.log(`âŒ Failed to update tag ${tag.name} to match upstream`);
                  failedTags.push(`${tag.name} (update failed)`);
                }
              } else {
                // Case 3: Tag exists and already matches upstream
                console.log(`Tag ${tag.name} already matches upstream commit ${tag.commit.sha}`);
              }
            }

            // Fail the workflow if any tags couldn't be synced
            if (failedTags.length > 0) {
              const errorMessage = `Failed to sync the following tags with upstream: ${failedTags.join(", ")}`;
              console.error(errorMessage);
              throw new Error(errorMessage);
            }

      - name: Mirror releases from upstream
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const upstream = process.env.UPSTREAM_REPO;
            const [upstreamOwner, upstreamRepo] = upstream.split('/');

            console.log(`Mirroring releases from upstream: ${upstream}`);

            try {
              // Get all releases from upstream
              const { data: upstreamReleases } = await github.rest.repos.listReleases({
                owner: upstreamOwner,
                repo: upstreamRepo,
                per_page: 100
              });

              console.log(`Found ${upstreamReleases.length} releases in upstream repository`);

              // Get all releases in the current repo
              const { data: forkReleases } = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });

              console.log(`Found ${forkReleases.length} releases in fork repository`);
              const forkReleases_map = new Map();
              forkReleases.forEach(release => {
                forkReleases_map.set(release.tag_name, release);
              });

              // Mirror releases that don't exist in the fork
              let mirrored = 0;
              const failedReleases = [];

              for (const release of upstreamReleases) {
                if (!forkReleases_map.has(release.tag_name)) {
                  console.log(`Mirroring release: ${release.tag_name} - ${release.name}`);
                  try {
                    await github.rest.repos.createRelease({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      tag_name: release.tag_name,
                      name: release.name,
                      body: `${release.body || ''}\n\n---\n*This release was automatically mirrored from the upstream repository.*`,
                      draft: release.draft,
                      prerelease: release.prerelease,
                      target_commitish: release.target_commitish || 'main'
                    });
                    mirrored++;
                    console.log(`Successfully mirrored release: ${release.tag_name}`);
                  } catch (error) {
                    console.error(`Error mirroring release ${release.tag_name}:`, error.message);
                    failedReleases.push(`${release.tag_name} (${error.message})`);
                  }
                }
              }

              // Fail the workflow if any releases couldn't be mirrored
              if (failedReleases.length > 0) {
                const errorMessage = `Failed to mirror the following releases: ${failedReleases.join(", ")}`;
                console.error(errorMessage);
                throw new Error(errorMessage);
              }

              console.log(`Sync complete. Successfully mirrored ${mirrored} new releases.`);
            } catch (error) {
              console.error('Error in release mirroring process:', error);
              throw error;
            }

      - name: Sync Summary
        run: |
          echo "## Repository Sync Summary" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Branch Sync**: All branches synchronized with upstream" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Tags Sync**: All tags synchronized with upstream" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Release Sync**: All releases mirrored from upstream" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ”„ Synchronized with upstream: $UPSTREAM_REPO" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Last sync time: $(date)" >> $GITHUB_STEP_SUMMARY
